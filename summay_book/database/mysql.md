# mysql

* innodb与myisam的区别

    事务安全：innodb支持事务，而myisam不支持
    
    外键：myisam不支持外键，innodb支持

    锁机制： myisam是表锁， innodb是行锁

    全文索引：myisam支持全文索引，innodb不支持

    myisam空间使用率比innodb低（innodb使用了内存缓存，而myisam直接读写磁盘）

* 事务的特性？
    
    原子性，隔离性，持久性，一致性

* 数据库事务隔离级别的区别？

    读未提交： 一个事务写数据时，允许其他事务读取数据。会出现脏读

    读已提交：读取数据的事务允许其他事务对数据进行操作，会出现不可重复读（虚读），避免了脏读

    可重复读：禁止写事务，允许读事务，避免了脏读和不可重复读，但是会出现幻读

    串行化：禁止任何事务，一个一个执行。是最高的隔离级别

* sql索引创建规则？

    表的主键外键必须有索引
    
    数据超过300的表必须有索引
    
    经常与其他表进行连接的表，在连接字段上应该有索引
    
    经常出现在where子句中的字段，特别是大表的字段，应该建立索引
    
    索引应该建立在选择性高的字段上
    
    索引应该建立在小字段上，对于大的文本字段甚至超长字段，不要建立索引
    
    复合索引尽量使用单字段索引替代
    
    频繁进行数据操作的表，不适合建立太多索引
    
    删除无用的索引

    空列避免使用索引

* 多表连表查询时如何优化？

* 垂直分表原则？
  
  把不常用的字段放在单独一张表

  把text， blob等大字段放在附表

  经常组合查询的列放在一张表

* 水平分表原则？

 使用取模的方式进行表的拆分

* sql优化？

    select时尽量使用列名，避免select *

    尽量使用多表连接，避免子查询

    尽量在wherer字句中完成数据的过滤。on, where, having都具有过滤行为，越早完成过滤下一阶段要处理的数据量就越少

    使用exist替换in,in会对子查询进行全表扫面，降低性能

    使用索引

    order by子句中不要使用非索引列或嵌套表达式

    避免使用not运算符

    使用union代替or.索引列上的or会造成全表扫面

    尽量使用>=，而不用>


* 什么情况下索引失效？
  
    在索引上使用函数

    使用like "%t%"时，无法使用索引，但like "t%"可以使用

    not运算符无法使用索引

* inner join(内连接), right join（右连接）, left join（右连接）, full join（全连接） 的区别？
  
    inner join在连接时，只保留与连接表完全匹配的结果集

    right join在查询时，会返回右表所有的行，即使在左表中没有匹配的记录

    left join在查询时，会返回左表中所有的行，即使在右表中中没有记录

    full join在查询时，会返回两张表的笛卡尔积


* 唯一索引与主键索引的区别？
  
  主键是约束，唯一索引是索引
  
  一张表只能由一个主键，但可以有多个唯一索引
  
  主键创建后一定包含一个唯一索引，但唯一索引不一定是主键
  
  主键不能为null,唯一索引可以
  
  主键可以做外键，唯一索引不行

* count(*)和count(column)有什么区别？
  
    count(*) 会统计所有的行，count(column)执行时，当这个字段的值为null时，会忽略这一行

* where, group by, having和order by 的执行顺序？
    
    执行顺序是Where —> Group By -> Having -> Order by, 过程：where会将查询中不满足条件的过滤掉，然后通过group by后的关键字将筛选得到的视图进行分组，然后通过having后的条件将筛选后不符合条件的过滤掉，
    最后按照order by语句对视图进行排序，产生最后结果






  